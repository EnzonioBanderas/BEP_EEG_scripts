% 4 figures per file
% Plots 1) dynamical acceleration vector length distribution with a mixed gaussian
% fit and uses relative probability thresholds to divide channel data into Awake/Sleep.
% Plots 2) dynamical acceleration vector length over time.
% Plots 3) normalized spectrograms and 
%       4) absolute PSD for Awake/Sleep for each channel
% Saves PSD data with relevant measurement information into a table to be used by Plotter.m

% Note that there is a slight discontinuity for when the selected data
% generated by EEG_select contains more than one selection area.
clearvars, close all
%% Input 
Settings.window=2; % s
Settings.overlap=0.5; % ratio
Settings.HP_ele = 0.1; % Hz
Settings.LP_ele = 100; % Hz
Settings.HP_acc = 1; % Hz
Settings.p_value=.03; % probability
Settings.normFreq_ele=50; % Hz upper limit for normalized spectrogram
Settings.timeBin=60; % s
Settings.StateString={'Awake','Sleep'};
Settings.window_detrend=1; % s
Settings.overlap_detrend=0.5; % ratio

nState=length(Settings.StateString);

% Select to be analyzed .mat files
[FileName,PathName] = uigetfile('*.mat','Select the file to analyse','MultiSelect', 'on');
if ischar(FileName) %if-statement for the case that only one file is selected
    FileName={FileName}; 
end
cd(PathName)

%% Plot setttings
% plot property 'Color'
Settings.c=colormap(lines); % colors to most contrasting color map
Settings.c([1,2],:)=Settings.c([2,1],:);
close all

% plot property 'LineStyle'
Settings.ls={'-';'--';':';'-.'};

%% Import select logicals
load('DataTable_Logical') % File created by Select_Truncation.m

nExperiments=length(FileName);
DataTable_cell=cell(nExperiments,1);
% Start of loop through experiments
for experiment_index=1:nExperiments
Mouse=FileName{experiment_index}(1:end-4);

% Index for DataTable_logical which is used for the truncation
temp.select_index=find(strcmp(Mouse,DataTable_Logical.Experiment_Name));

%% Import experiment data
% import data from .mat file
load(FileName{experiment_index},'Acceleration','Electrical')

%% Constants and Truncation of data depending on EEG_Select.m output and length of bins
% create time vectors (to also truncate)
Electrical.t=(0:1/Electrical.fs:(size(Electrical.CH1234,1)-1)/Electrical.fs)'; % s
Acceleration.t=(0:1/Acceleration.fs:(size(Acceleration.XYZ,1)-1)/Acceleration.fs)'; % s

% truncate acceleration % can still be changed to be correct for overlap
% with buffer overlap truncation becomes unnecessary
Acceleration.Select=DataTable_Logical.Select_Acceleration{temp.select_index};
Acceleration.Select_points=logical2points(Acceleration.Select);
temp.segment_length=Acceleration.Select_points(:,2)-Acceleration.Select_points(:,1)+1;
Acceleration.nBin=round(Settings.timeBin*Acceleration.fs);
Acceleration.Select_points(:,2)=Acceleration.Select_points(:,2)-mod(temp.segment_length,Acceleration.nBin);
Acceleration.Select=points2logical(Acceleration.Select_points);
Acceleration.XYZ=Acceleration.XYZ(Acceleration.Select,:);
Acceleration.t=Acceleration.t(Acceleration.Select);

% truncate electrical
Electrical.Select=DataTable_Logical.Select_Electrical{temp.select_index};
Electrical.Select_points=logical2points(Electrical.Select);
temp.segment_length=Electrical.Select_points(:,2)-Electrical.Select_points(:,1)+1;
Electrical.nBin=round(Settings.timeBin*Electrical.fs);
Electrical.Select_points(:,2)=Electrical.Select_points(:,2)-mod(temp.segment_length,Electrical.nBin);
Electrical.Select=points2logical(Electrical.Select_points);
Electrical.CH1234=Electrical.CH1234(Electrical.Select,:);
Electrical.t=Electrical.t(Electrical.Select);

% some constants for acceleration data
Acceleration.n=length(Acceleration.t);
Acceleration.nCol=Acceleration.n/Acceleration.nBin;
Acceleration.nDim=size(Acceleration.XYZ,2);
% some constants for electrical data
Electrical.n=length(Electrical.t);
Electrical.nCol=Electrical.n/Electrical.nBin;
Electrical.nChannel=size(Electrical.CH1234,2);

clearvars temp
%% Approximate dynamic acceleration by applying a high-pass filter and calculate length of vector
% approximate XYZ dynamic acceleration by applying a high-pass filter
Acceleration.dyn=[HighPassfilter(2,Settings.HP_acc,Acceleration.fs,Acceleration.XYZ(:,1)),...
                  HighPassfilter(2,Settings.HP_acc,Acceleration.fs,Acceleration.XYZ(:,2)),...
                  HighPassfilter(2,Settings.HP_acc,Acceleration.fs,Acceleration.XYZ(:,3))];
                   
% calculate length of XYZ dynamic acceleration vector
Acceleration.dyn=vecnorm(Acceleration.dyn,2,2);

%% Calculate mean of dynamical acceleration vecotr and fit mixed Gaussian distribution
% reshape dyn into even parts (1 min bins)
Acceleration.dyn_mean=reshape(Acceleration.dyn,[Acceleration.nBin,Acceleration.nCol]);

% mean reshaped dyn
Acceleration.dyn_mean=mean(Acceleration.dyn_mean)';
   
% fit mixture of gaussians
temp.gmd=fitgmdist(Acceleration.dyn_mean,2);

% Indexing: temp.index(1) is the index integer for the distribution with the higher mean
% which should be Awake, alseep is then temp.index(2) with the lower mean
[~,temp.index]=sort(temp.gmd.mu,'descend');
Awake.sigma=temp.gmd.Sigma(temp.index(1));
Awake.mu=temp.gmd.mu(temp.index(1));
Awake.proportion=temp.gmd.ComponentProportion(temp.index(1));
Sleep.sigma=temp.gmd.Sigma(temp.index(2));
Sleep.mu=temp.gmd.mu(temp.index(2));
Sleep.proportion=temp.gmd.ComponentProportion(temp.index(2));

% Individual and combined probability density functions (pdf) normalized from 0 to inf
Awake.norm=1/(sqrt(pi*Awake.sigma/2)*(1+erf(Awake.mu/sqrt(2*Awake.sigma))));
Awake.pdf=@(dyn)Awake.norm*exp(-((dyn-Awake.mu).^2)/(2*Awake.sigma));

Sleep.norm=1/(sqrt(pi*Sleep.sigma/2)*(1+erf(Sleep.mu/sqrt(2*Sleep.sigma))));
Sleep.pdf=@(dyn)Sleep.norm*exp(-((dyn-Sleep.mu).^2)/(2*Sleep.sigma));

combined_pdf=@(dyn)Awake.proportion*Awake.pdf(dyn)+Sleep.proportion*Sleep.pdf(dyn);

clearvars temp
%% Use pdf to divide signal into Awake and Sleep
% calculate Awake threshold (analytically)
temp.polynomial_constant=4*Awake.sigma*Sleep.sigma;
temp.polynomial(1)=(2*Sleep.sigma-2*Awake.sigma)/temp.polynomial_constant;
temp.polynomial(2)=(4*Sleep.mu*Awake.sigma-4*Awake.mu*Sleep.sigma)/temp.polynomial_constant;
temp.polynomial(3)=(2*Awake.mu^2*Sleep.sigma-2*Sleep.mu^2*Awake.sigma)/temp.polynomial_constant;
temp.probability_constant=log((Awake.norm*Settings.p_value)/(Sleep.norm*(1-Settings.p_value)));
temp.polynomial_adjusted=temp.polynomial;
temp.polynomial_adjusted(3)=temp.polynomial(3)-temp.probability_constant;
temp.Awake_threshold=roots(temp.polynomial_adjusted);
% calculate Sleep threshold
temp.polynomial=-temp.polynomial;
temp.probability_constant=log((Sleep.norm*Settings.p_value)/(Awake.norm*(1-Settings.p_value)));
temp.polynomial_adjusted=temp.polynomial;
temp.polynomial_adjusted(3)=temp.polynomial(3)-temp.probability_constant;
temp.Sleep_threshold=roots(temp.polynomial_adjusted);

%Name_string choose to leave out -sqrt(D) solution
Awake.threshold=max(temp.Awake_threshold);
Sleep.threshold=max(temp.Sleep_threshold);

clearvars temp
%% Use threshold to create state logicals and points
    
% Initialize    
Acceleration.Awake=false(Acceleration.nBin,Acceleration.nCol);
Acceleration.Sleep=Acceleration.Awake;
Electrical.Awake=false(Electrical.nBin,Electrical.nCol);
Electrical.Sleep=Electrical.Awake;

% Assign Awake logical values for acceleration and electrical data
temp.logical=Acceleration.dyn_mean>Awake.threshold&Acceleration.dyn_mean>Sleep.threshold;
temp.nCol=sum(temp.logical);
Acceleration.Awake(:,temp.logical)=true(Acceleration.nBin,temp.nCol);
Electrical.Awake(:,temp.logical)=true(Electrical.nBin,temp.nCol);
% Assign Sleep logical values for acceleration and electrical data
temp.logical=Acceleration.dyn_mean<Sleep.threshold&Acceleration.dyn_mean<Awake.threshold;
temp.nCol=sum(temp.logical);
Acceleration.Sleep(:,temp.logical)=true(Acceleration.nBin,temp.nCol);
Electrical.Sleep(:,temp.logical)=true(Electrical.nBin,temp.nCol);

% Convert matrices to logical arrays
Acceleration.Awake=reshape(Acceleration.Awake,[Acceleration.n,1]);
Electrical.Awake=reshape(Electrical.Awake,[Electrical.n,1]);
Acceleration.Sleep=reshape(Acceleration.Sleep,[Acceleration.n,1]);
Electrical.Sleep=reshape(Electrical.Sleep,[Electrical.n,1]);

% Assign indeterminate logical array values for acceleration and electrical data
Acceleration.indeterminate=~(Acceleration.Awake|Acceleration.Sleep);
Electrical.indeterminate=~(Electrical.Awake|Electrical.Sleep);

% Convert logical arrays to points
Acceleration.Awake_points=logical2points(Acceleration.Awake);
Electrical.Awake_points=logical2points(Electrical.Awake);
Acceleration.Sleep_points=logical2points(Acceleration.Sleep);
Electrical.Sleep_points=logical2points(Electrical.Sleep);
Acceleration.indeterminate_points=logical2points(Acceleration.indeterminate);
Electrical.indeterminate_points=logical2points(Electrical.indeterminate);

% clearvars temp
%% Detrend and Filter Electrical signals     
% Detrend
% Electrical.LinearFit=zeros(Electrical.n,Electrical.nChannel);
% for j=1:Electrical.nChannel
%     
%     n_w=round(Settings.window_detrend*Electrical.fs); %number of points of window
%     n_o=round(n_w*Settings.overlap_detrend); %number of points of overlap
%     Electrical.LinearFit(:,j)=LineFit(Electrical.CH1234(:,j),n_w,n_o); % fit line to data
% %     Electrical.CH1234(:,j)=Electrical.CH1234(:,j)-Electrical.LinearFit(:,j); % subtract linear fit
%     
% end

% Filter
for j=1:Electrical.nChannel % Loop through channels
Electrical.CH1234(:,j) = HighPassfilter(2, Settings.HP_ele, Electrical.fs, Electrical.CH1234(:,j));
Electrical.CH1234(:,j) = LowPassfilter(2, Settings.LP_ele, Electrical.fs, Electrical.CH1234(:,j));
end

%% Start of plotting
% %% Plot of electrical data
% temp.points={Electrical.Awake_points,Electrical.Sleep_points,Electrical.indeterminate_points};
% figure('Name','Electrical')
% for j=1:Electrical.nChannel
%     subplot(Electrical.nChannel,1,j)
%     hold on
%     xlabel('Time (s)'),ylabel('Amplitude (mV)')
%     title(['CH',num2str(j)])
%     xlim(Electrical.t([1,end]))
%     for jj=1:length(temp.points)
%         for jjj=1:size(temp.points{jj},1)
%             temp.index=temp.points{jj}(jjj,1):temp.points{jj}(jjj,2);
%             plot(Electrical.t(temp.index),Electrical.CH1234(temp.index,j),...
%                  'Color',Settings.c(jj,:))
% %             plot(Electrical.t(temp.index),Electrical.LinearFit(temp.index,j),...
% %                  'Color',Settings.c(jj,:))
%         end
%     end
% end

%% Plot histogram with pdf (TD: patch for Awake, Sleep indeterminate and legend etc.)
% temp.dyn=-10:0.0001:10;
% temp.lw=2.5;
% temp.N=floor(length(Acceleration.dyn_mean)/5);
% 
% figure('Name',[Mouse,' Histogram with pd'])
% histogram(Acceleration.dyn_mean,temp.N,'Normalization','pdf'), hold on
% plot(temp.dyn,combined_pdf(temp.dyn),'LineWidth',temp.lw)
% temp.h=gca;
% plot(Awake.threshold*ones(2,1),temp.h.YLim,'LineWidth',temp.lw)
% plot(Sleep.threshold*ones(2,1),temp.h.YLim,'LineWidth',temp.lw)
% % patch([Sleep.threshold],...
% %       [0])
% xlim([0,max(Acceleration.dyn_mean)])
% xlabel('Mean absolute change in acceleration over time'),ylabel('Probability')

%% Length of dynamical acceleration vector plot
% temp.points={Acceleration.Awake_points,Acceleration.Sleep_points,Acceleration.indeterminate_points};
% 
% figure('Name',[Mouse,' Change of acceleration state plot'])
% for j=1:nState+1 % state
%     for jj=1:size(temp.points{j},1)
%         
%     plot(Acceleration.t(temp.points{j}(jj,1):temp.points{j}(jj,2)),...
%          Acceleration.dyn(temp.points{j}(jj,1):temp.points{j}(jj,2)),...
%          'Color',Settings.c(j,:)), hold on
% 
%     end
% end
% xlabel('Time (s)'), ylabel('Absolute change of acceleration ^{1}/_{g*s}')
% 
% clearvars temp
%% Calculate and plot FFT's
% FFT pre-processing
temp.window =   round(Electrical.fs*Settings.window);
temp.noverlap = round(temp.window*Settings.overlap);
temp.nfft = temp.window;

temp.points={Electrical.Awake_points,Electrical.Sleep_points};
Electrical.PSD_cell=cell(2,Electrical.nChannel);

% calculate PSD with spectrogram with points
figure('Name',[Mouse,' Normalized Spectrogram'])
for j=1:nState % State
for jj=1:Electrical.nChannel % Channel
    
    temp.nPoints=size(temp.points{j},1);
    temp.ps=cell(temp.nPoints,1);
    for jjj=1:temp.nPoints

    [~,~,~,temp.ps{jjj}]=spectrogram(Electrical.CH1234(temp.points{j}(jjj,1):temp.points{j}(jjj,2),jj),...
    temp.window, temp.noverlap, temp.nfft, Electrical.fs);

    end
    temp.ps=cat(2,temp.ps{:});
    
% % plot normalized (Settings.HP_ele-maxFreq Hz) spectrogram
% subplot(Electrical.nChannel,2,j+(jj-1)*2)
% temp.fff=0:Electrical.fs/temp.nfft:Electrical.fs/2; % approximate frequency bins positions directly
% temp.ttt=Settings.window*Settings.overlap:Settings.window*Settings.overlap:size(temp.ps,2); % approximate center time position of PSDs directly
% temp.ps_norm=(temp.ps./bandpower2(temp.ps,temp.fff,[Settings.HP_ele,Settings.normFreq_ele]))*100; %normalized power spectrum with frequencies of interest (%)
% imagesc(temp.ttt,temp.fff,temp.ps_norm)
% set(gca,'YDir','normal')
% colormap('PARULA')
% caxis([0,mean(max(temp.ps_norm))])
% colorbar              
% xlabel('Time (s)'),ylabel('Lfs PSD (%)')
% ylim([Settings.HP_ele,Settings.normFreq_ele])
% 
% if j==1
%     title(['Awake CH',num2str(jj)])
% else
%     title(['Sleep CH',num2str(jj)]);
% end
% 
Electrical.PSD_cell{j,jj}=mean(temp.ps,2); % rows for Awake/Sleep, columns for channels

end
end

%% PSD plot
% figure('Name',[Mouse,' PSD'])
% for j=1:nState % state
% for jj=1:Electrical.nChannel % channel
%     
% subplot(Electrical.nChannel,2,j+(jj-1)*2)
% plot(temp.fff,Electrical.PSD_cell{j,jj})
% xlim([Settings.HP_ele,50])
%     
% if j==1
%     title(['Awake CH',num2str(jj)])
% else
%     title(['Sleep CH',num2str(jj)]);
% end
%     
% end
% end
% xlabel('Frequency (Hz)'), ylabel('Power \muV^2')
% 
% clearvars temp
%% Convert variables to DataTable 
Mouse=strsplit(Mouse,'_');
Name=Mouse(1);
Genotype=Mouse(2); 
Day=Mouse(3);
Channel={'CH1','CH2','CH3','CH4'};

nPSD_cell=numel(Electrical.PSD_cell);

Name_string=strings(nPSD_cell,1);
Genotype_string=Name_string;
Day_string=Name_string;
Channel_string=Name_string;
State_string=Name_string;
PSD_table_cell=cell(nPSD_cell,1);
Electrical_fs=zeros(nPSD_cell,1);

Name_string(1:end)=Name;
Genotype_string(1:end)=Genotype;
Day_string(1:end)=Day;

count=0;
for d=1:nState % States
    for dd=1:Electrical.nChannel % Channels
    
    count=count+1;    
        
    Channel_string(count)=Channel(dd);
    State_string(count)=Settings.StateString(d);
    PSD_table_cell(count)=Electrical.PSD_cell(d,dd);
    Electrical_fs(count)=Electrical.fs;

    end
end

TableNames={'Name','Genotype','Day','Channel','State','Power','fs'};
DataTable_cell{experiment_index}=table(Name_string,Genotype_string,Day_string,Channel_string,State_string,...
                PSD_table_cell,Electrical_fs,...
                'VariableNames',TableNames);

clearvars -except Settings FileName PathName nExperiments experiment_index DataTable_cell DataTable_Logical
end

% save datatable and settings
cd ..
DataTable=cat(1,DataTable_cell{:});
save(['DataTable_Automatic_1Hz_',GetTime,'.mat'],'DataTable')
save('Settings','Settings')