% % Some new variables
% Settings.StateSleepString=["REM","NREM"];
% nStateSleep=length(Settings.StateSleepString);

%% OLD: 1) reshape-->buffer 2) add 2 dimensional plot delta-theta, spectrogram(time_bin)
% 4 figures per file
% Plots 1) dynamical acceleration vector length distribution with a mixed gaussian
% fit and uses relative probability thresholds to divide channel data into Awake/Sleep.
% Plots 2) dynamical acceleration vector length over time.
% Plots 3) normalized spectrograms and 
%       4) absolute PSD for Awake/Sleep for each channel
% Saves PSD data with relevant measurement information into a table to be used by Plotter.m

% Note that there is a slight discontinuity for when the selected data
% generated by EEG_select contains more than one selection area.
clearvars, close all
%% Input 
Settings.window=2; % s
Settings.overlap=0.5; % ratio
Settings.HP_ele = 0.1; % Hz
Settings.LP_ele = 100; % Hz
Settings.HP_acc = 1; % Hz
Settings.p_value=.03; % probability
Settings.normFreq_ele=50; % Hz upper limit for normalized spectrogram
Settings.timeBin=10; % s
Settings.timeBin_overlap=0.5; % ratio
Settings.timeBin_ele=2; % s
Settings.timeBin_overlap_acc=0.5; % overlap
Settings.StateString={'Awake','Sleep'};
Settings.window_detrend=1; % s
Settings.overlap_detrend=0.5; % ratio
Settings.delta_range=[1,4];
Settings.theta_range=[5,10];
Settings.beta_range=[13,30];
Settings.gamma_range=[30,50];

% Some constants
nState=length(Settings.StateString);

% Select to be analyzed .mat files
[E_Name,PathName] = uigetfile('*.mat','Select the file to analyse','MultiSelect', 'on');
if ischar(E_Name) %if-statement for the case that only one file is selected
    E_Name={E_Name}; 
end
cd(PathName)

%% Plot setttings
% plot property 'Color'
Settings.c=colormap(lines); % colors to most contrasting color map
Settings.c([1,2],:)=Settings.c([2,1],:);
close(gcf)

% plot property 'LineStyle'
Settings.ls={'-';'--';':';'-.'};

%% Import select logicals
load('DataTable_Select') % File created by EEG_Select.m

nE=length(E_Name);
DataTable_cell=cell(nE,1);
% Start of loop through experiments
for E_index=1:nE
Mouse=E_Name{E_index}(1:end-4);

%% Import experiment data
% import data from .mat file
load(E_Name{E_index},'Acceleration','Electrical')

%% Get selection of data defined by EEG_Select.m
% Index for DataTable_Select which is used for the truncation
select_index=find(strcmp(Mouse,DataTable_Select.Experiment_Name));
% Get selection
Acceleration.points=DataTable_Select.Select_Acceleration{select_index};
Electrical.points=DataTable_Select.Select_Electrical{select_index};

%% Create time vectors and general constants
Electrical.n=size(Electrical.CH1234,1);
Acceleration.n=size(Acceleration.XYZ,1);
Electrical.t=(0:1/Electrical.fs:(Electrical.n-1)/Electrical.fs)'; % s
Acceleration.t=(0:1/Acceleration.fs:(Acceleration.n-1)/Acceleration.fs)'; % s
Electrical.nChannel=size(Electrical.CH1234,2);
Acceleration.nDim=size(Acceleration.XYZ,2);

%% Acceleration Awake/Sleep division
%% Approximate dynamic acceleration by applying a high-pass filter and calculate length of vector
% approximate XYZ dynamic acceleration by applying a high-pass filter
Acceleration.dyn=[HighPassfilter(2,Settings.HP_acc,Acceleration.fs,Acceleration.XYZ(:,1)),...
                  HighPassfilter(2,Settings.HP_acc,Acceleration.fs,Acceleration.XYZ(:,2)),...
                  HighPassfilter(2,Settings.HP_acc,Acceleration.fs,Acceleration.XYZ(:,3))];
                   
% calculate length of XYZ dynamic acceleration vector
Acceleration.dyn=vecnorm(Acceleration.dyn,2,2);

%% Divide Acceleration data into overlapping bins
% Some constants
Acceleration.nBinLength=round(Settings.timeBin*Acceleration.fs); % around Settings.timeBin seconds
Acceleration.nBinOverlap=round(Acceleration.nBinLength*Settings.timeBin_overlap); % around Settings.timeBin_overlap*Settings.timeBin seconds

% buffer dyn into overlapping bins (1 min bins)
Acceleration.Bin=buffer_dis(Acceleration.dyn,Acceleration.nBinLength,Acceleration.nBinOverlap,Acceleration.points);
Acceleration.dim=size(Acceleration.Bin);

%% Calculate mean of dynamical acceleration vector and fit mixed Awake/Sleep Gaussian distribution
% mean bins of dynamic acceleration lengths
Acceleration.Bin=mean(Acceleration.Bin)';
   
% fit mixture of gaussians
gmd=fitgmdist(Acceleration.Bin,2);

% Indexing: index_state(1) is the index integer for the distribution with the higher mean
% which should be Awake, Sleep is then index_state(2) with the lower mean
[~,index_state]=sort(gmd.mu,'descend');
Awake.sigma=gmd.Sigma(index_state(1));
Awake.mu=gmd.mu(index_state(1));
Awake.proportion=gmd.ComponentProportion(index_state(1));
Sleep.sigma=gmd.Sigma(index_state(2));
Sleep.mu=gmd.mu(index_state(2));
Sleep.proportion=gmd.ComponentProportion(index_state(2));

% Individual and combined probability density functions (pdf) normalized from 0 to inf
Awake.norm=1/(sqrt(pi*Awake.sigma/2)*(1+erf(Awake.mu/sqrt(2*Awake.sigma))));
Awake.pdf=@(dyn)Awake.norm*exp(-((dyn-Awake.mu).^2)/(2*Awake.sigma));

Sleep.norm=1/(sqrt(pi*Sleep.sigma/2)*(1+erf(Sleep.mu/sqrt(2*Sleep.sigma))));
Sleep.pdf=@(dyn)Sleep.norm*exp(-((dyn-Sleep.mu).^2)/(2*Sleep.sigma));

pdf_combined=@(dyn)Awake.proportion*Awake.pdf(dyn)+Sleep.proportion*Sleep.pdf(dyn);

%% Use pdf to divide signal into Awake and Sleep
% calculate Awake threshold (analytically)
polynomial_constant=4*Awake.sigma*Sleep.sigma;
polynomial(1)=(2*Sleep.sigma-2*Awake.sigma)/polynomial_constant;
polynomial(2)=(4*Sleep.mu*Awake.sigma-4*Awake.mu*Sleep.sigma)/polynomial_constant;
polynomial(3)=(2*Awake.mu^2*Sleep.sigma-2*Sleep.mu^2*Awake.sigma)/polynomial_constant;
probability_constant=log((Awake.norm*Settings.p_value)/(Sleep.norm*(1-Settings.p_value)));
polynomial_adjusted=polynomial;
polynomial_adjusted(3)=polynomial(3)-probability_constant;
Awake.threshold=roots(polynomial_adjusted);
% calculate Sleep threshold
polynomial=-polynomial;
probability_constant=log((Sleep.norm*Settings.p_value)/(Awake.norm*(1-Settings.p_value)));
polynomial_adjusted=polynomial;
polynomial_adjusted(3)=polynomial(3)-probability_constant;
Sleep.threshold=roots(polynomial_adjusted);

%Name_string choose to leave out -sqrt(D) solution
Awake.threshold=max(Awake.threshold);
Sleep.threshold=max(Sleep.threshold);

%% Use threshold to create state logicals and points
% Initialize    
Acceleration.Awake=false(Acceleration.dim);
Acceleration.Sleep=Acceleration.Awake;

% Assign Awake logical values for acceleration data
temp.logical=Acceleration.Bin>Awake.threshold&Acceleration.Bin>Sleep.threshold;
temp.nCol=sum(temp.logical);
Acceleration.Awake(:,temp.logical)=true(Acceleration.nBinLength,temp.nCol);
% Assign Sleep logical values for acceleration data
temp.logical=Acceleration.Bin<Sleep.threshold&Acceleration.Bin<Awake.threshold;
temp.nCol=sum(temp.logical);
Acceleration.Sleep(:,temp.logical)=true(Acceleration.nBinLength,temp.nCol);

% Convert overlapping bins to logical array
bin_overlap_threshold=floor(Acceleration.nBinOverlap/(Acceleration.nBinLength-Acceleration.nBinOverlap)); % how many windows can have same overlap?
Acceleration.Awake = buffer_inv_dis(Acceleration.Awake,Acceleration.nBinOverlap,'sum',Acceleration.points,Acceleration.n)>bin_overlap_threshold;
Acceleration.Sleep = buffer_inv_dis(Acceleration.Sleep,Acceleration.nBinOverlap,'sum',Acceleration.points,Acceleration.n)>bin_overlap_threshold;

% Assign Indeterminate logical array values for acceleration and electrical data
Acceleration.Indeterminate=~(Acceleration.Awake|Acceleration.Sleep);

% Convert logical arrays to points
Acceleration.Awake_points=logical2points(Acceleration.Awake);
Acceleration.Sleep_points=logical2points(Acceleration.Sleep);
Acceleration.Indeterminate_points=logical2points(Acceleration.Indeterminate);

%% Electrical REM/NREM division
%% Filter Electrical data
for j=1:Electrical.nChannel % Loop through channels
Electrical.CH1234(:,j) = HighPassfilter(2, Settings.HP_ele, Electrical.fs, Electrical.CH1234(:,j));
Electrical.CH1234(:,j) = LowPassfilter(2, Settings.LP_ele, Electrical.fs, Electrical.CH1234(:,j));
end

%% Get selection for Electrical data from Acceleration state division
% Convert Acceleration points to Electrical points by using the fact that
% the sampling rate of the electrical data is a multiple of the sampling 
% rate of the acceleration data.
EleAccMultiple=round(Electrical.fs/Acceleration.fs);
Electrical.Awake_points=[Acceleration.Awake_points(:,1)*EleAccMultiple-(EleAccMultiple-1),...
                         Acceleration.Awake_points(:,2)*EleAccMultiple];
Electrical.Sleep_points=[Acceleration.Sleep_points(:,1)*EleAccMultiple-(EleAccMultiple-1),...
                         Acceleration.Sleep_points(:,2)*EleAccMultiple];
Electrical.Indeterminate_points=[Acceleration.Indeterminate_points(:,1)*EleAccMultiple-(EleAccMultiple-1),...
                                 Acceleration.Indeterminate_points(:,2)*EleAccMultiple];
                             
%% Get constants for Electrical data from Acceleration constants
Electrical.nBinLength=Acceleration.nBinLength*EleAccMultiple;
Electrical.nBinOverlap=Acceleration.nBinOverlap*EleAccMultiple;

%% Repeat same process for Electrical.test, delta and theta
% chose some test channel
Electrical.test = Electrical.CH1234(:,2);

% seperate test data into bins and get dimensions of resulting buffered matrix
Electrical.Bin_Sleep = buffer_dis(Electrical.test,Electrical.nBinLength,Electrical.nBinOverlap,Electrical.Sleep_points);
Electrical.dim_Sleep = size(Electrical.Bin_Sleep);
Electrical.Bin_Awake = buffer_dis(Electrical.test,Electrical.nBinLength,Electrical.nBinOverlap,Electrical.Awake_points);
Electrical.dim_Awake = size(Electrical.Bin_Awake);

% predefine state logicals
Electrical.REM  = false(Electrical.dim_Sleep);
Electrical.NREM = Electrical.REM;

% FFT settings
Electrical.nWindowLength = round(Settings.window*Electrical.fs);
Electrical.nOverlap      = round(Electrical.nWindowLength*Settings.overlap);
Electrical.nFFT          = Electrical.nWindowLength;

% preallocation
Electrical.Bin_PSD_Sleep        = zeros(floor(Electrical.nFFT/2)+1,Electrical.dim_Sleep(2));
Electrical.Bin_BandPowers_Sleep = zeros(Electrical.dim_Sleep(2),2);
Electrical.Bin_PSD_Awake        = zeros(floor(Electrical.nFFT/2)+1,Electrical.dim_Awake(2));
Electrical.Bin_BandPowers_Awake = zeros(Electrical.dim_Awake(2),2);

% compute delta and theta powers _Sleep
for i=1:Electrical.dim_Sleep(2) % loop through bins
    [~,Electrical.Bin_fff,~,Bin_PSD_Sleep]=spectrogram(Electrical.Bin_Sleep(:,i),Electrical.nWindowLength,Electrical.nOverlap,Electrical.nFFT,Electrical.fs);
    Electrical.Bin_PSD_Sleep(:,i)=mean(Bin_PSD_Sleep,2);
    Electrical.Bin_BandPowers_Sleep(i,1)=bandpower2(Electrical.Bin_PSD_Sleep(:,i),Electrical.Bin_fff,Settings.delta_range);
    Electrical.Bin_BandPowers_Sleep(i,2)=bandpower2(Electrical.Bin_PSD_Sleep(:,i),Electrical.Bin_fff,Settings.theta_range);
    Electrical.Bin_BandPowers_Sleep(i,3)=bandpower2(Electrical.Bin_PSD_Sleep(:,i),Electrical.Bin_fff,Settings.beta_range);
    Electrical.Bin_BandPowers_Sleep(i,4)=bandpower2(Electrical.Bin_PSD_Sleep(:,i),Electrical.Bin_fff,Settings.gamma_range);
end
% compute delta and theta powers _Awake
for i=1:Electrical.dim_Awake(2)
    [~,Electrical.Bin_fff,~,Bin_PSD_Awake]=spectrogram(Electrical.Bin_Awake(:,i),Electrical.nWindowLength,Electrical.nOverlap,Electrical.nFFT,Electrical.fs);
    Electrical.Bin_PSD_Awake(:,i)=mean(Bin_PSD_Awake,2);
    Electrical.Bin_BandPowers_Awake(i,1)=bandpower2(Electrical.Bin_PSD_Awake(:,i),Electrical.Bin_fff,Settings.delta_range);
    Electrical.Bin_BandPowers_Awake(i,2)=bandpower2(Electrical.Bin_PSD_Awake(:,i),Electrical.Bin_fff,Settings.theta_range);
    Electrical.Bin_BandPowers_Awake(i,3)=bandpower2(Electrical.Bin_PSD_Awake(:,i),Electrical.Bin_fff,Settings.beta_range);
    Electrical.Bin_BandPowers_Awake(i,4)=bandpower2(Electrical.Bin_PSD_Awake(:,i),Electrical.Bin_fff,Settings.gamma_range);
end

%% Fit mixed Gaussian

%% Create logical then convert to points (indeterminate2?)

%% Plot 2-D histogram with pdf
figure('Name','2-D histogram')
hold on
histogram2(Electrical.Bin_BandPowers_Sleep(:,1),Electrical.Bin_BandPowers_Sleep(:,2));
histogram2(Electrical.Bin_BandPowers_Awake(:,1),Electrical.Bin_BandPowers_Awake(:,2));
legend({'Sleep','Awake'})

figure
hold on
histogram(Electrical.Bin_BandPowers_Sleep(:,1))
histogram(Electrical.Bin_BandPowers_Sleep(:,2))
histogram(Electrical.Bin_BandPowers_Sleep(:,3))
histogram(Electrical.Bin_BandPowers_Sleep(:,4))
legend({'delta','theta','beta','gamma'})

figure
hold on
histogram(Electrical.Bin_BandPowers_Awake(:,1))
histogram(Electrical.Bin_BandPowers_Awake(:,2))
histogram(Electrical.Bin_BandPowers_Awake(:,3))
histogram(Electrical.Bin_BandPowers_Awake(:,4))
legend({'delta','theta','beta','gamma'})

figure
hold on
histogram(Electrical.Bin_BandPowers_Sleep(:,1))
histogram(Electrical.Bin_BandPowers_Sleep(:,2))
legend({'delta','theta'})

%% Detrend and Filter Electrical signals     
% Detrend
% Electrical.LinearFit=zeros(Electrical.n,Electrical.nChannel);
% for j=1:Electrical.nChannel
%     
%     n_w=round(Settings.window_detrend*Electrical.fs); %number of points of window
%     n_o=round(n_w*Settings.overlap_detrend); %number of points of overlap
%     Electrical.LinearFit(:,j)=LineFit(Electrical.CH1234(:,j),n_w,n_o); % fit line to data
% %     Electrical.CH1234(:,j)=Electrical.CH1234(:,j)-Electrical.LinearFit(:,j); % subtract linear fit
%     
% end

%% Start of plotting
% %% Plot of electrical data
% temp.points={Electrical.Awake_points,Electrical.Sleep_points,Electrical.Indeterminate_points};
% figure('Name','Electrical')
% for j=1:Electrical.nChannel
%     subplot(Electrical.nChannel,1,j)
%     hold on
%     xlabel('Time (s)'),ylabel('Amplitude (mV)')
%     title(['CH',num2str(j)])
%     xlim(Electrical.t([1,end]))
%     for jj=1:length(temp.points)
%         for jjj=1:size(temp.points{jj},1)
%             index_state=temp.points{jj}(jjj,1):temp.points{jj}(jjj,2);
%             plot(Electrical.t(index_state),Electrical.CH1234(index_state,j),...
%                  'Color',Settings.c(jj,:))
% %             plot(Electrical.t(index_state),Electrical.LinearFit(index_state,j),...
% %                  'Color',Settings.c(jj,:))
%         end
%     end
% end

%% Plot histogram with pdf (TD: patch for Awake, Sleep Indeterminate and legend etc.)
temp.dyn=-10:0.0001:10;
temp.lw=2.5;
temp.N=floor(length(Acceleration.Bin)/5);

figure('Name',[Mouse,' Histogram with pd'])
histogram(Acceleration.Bin,temp.N,'Normalization','pdf'), hold on
plot(temp.dyn,pdf_combined(temp.dyn),'LineWidth',temp.lw)
temp.h=gca;
plot(Awake.threshold*ones(2,1),temp.h.YLim,'LineWidth',temp.lw)
plot(Sleep.threshold*ones(2,1),temp.h.YLim,'LineWidth',temp.lw)
% patch([Sleep.threshold],...
%       [0])
xlim([0,max(Acceleration.Bin)])
xlabel('Mean absolute change in acceleration over time'),ylabel('Probability')

%% Length of dynamical acceleration vector plot
% temp.points={Acceleration.Awake_points,Acceleration.Sleep_points,Acceleration.Indeterminate_points};
% 
% figure('Name',[Mouse,' Change of acceleration state plot'])
% for j=1:nState+1 % state
%     for jj=1:size(temp.points{j},1)
%         
%     plot(Acceleration.t(temp.points{j}(jj,1):temp.points{j}(jj,2)),...
%          Acceleration.dyn(temp.points{j}(jj,1):temp.points{j}(jj,2)),...
%          'Color',Settings.c(j,:)), hold on
% 
%     end
% end
% xlabel('Time (s)'), ylabel('Absolute change of acceleration ^{1}/_{g*s}')
% 
% clearvars temp
%% Calculate and plot FFT's
% FFT pre-processing
temp.window =   round(Electrical.fs*Settings.window);
temp.noverlap = round(temp.window*Settings.overlap);
temp.nfft = temp.window;

temp.points={Electrical.Awake_points,Electrical.Sleep_points};
Electrical.PSD_cell=cell(2,Electrical.nChannel);

% calculate PSD with spectrogram with points
figure('Name',[Mouse,' Normalized Spectrogram'])
for j=1:nState % State
for jj=1:Electrical.nChannel % Channel
    
    temp.nPoints=size(temp.points{j},1);
    temp.ps=cell(temp.nPoints,1);
    for jjj=1:temp.nPoints

    [~,~,~,temp.ps{jjj}]=spectrogram(Electrical.CH1234(temp.points{j}(jjj,1):temp.points{j}(jjj,2),jj),...
    temp.window, temp.noverlap, temp.nfft, Electrical.fs);

    end
    temp.ps=cat(2,temp.ps{:});
    
% % plot normalized (Settings.HP_ele-maxFreq Hz) spectrogram
% subplot(Electrical.nChannel,2,j+(jj-1)*2)
% temp.fff=0:Electrical.fs/temp.nfft:Electrical.fs/2; % approximate frequency bins positions directly
% temp.ttt=Settings.window*Settings.overlap:Settings.window*Settings.overlap:size(temp.ps,2); % approximate center time position of PSDs directly
% temp.ps_norm=(temp.ps./bandpower2(temp.ps,temp.fff,[Settings.HP_ele,Settings.normFreq_ele]))*100; %normalized power spectrum with frequencies of interest (%)
% imagesc(temp.ttt,temp.fff,temp.ps_norm)
% set(gca,'YDir','normal')
% colormap('PARULA')
% caxis([0,mean(max(temp.ps_norm))])
% colorbar              
% xlabel('Time (s)'),ylabel('Lfs PSD (%)')
% ylim([Settings.HP_ele,Settings.normFreq_ele])
% 
% if j==1
%     title(['Awake CH',num2str(jj)])
% else
%     title(['Sleep CH',num2str(jj)]);
% end
% 
Electrical.PSD_cell{j,jj}=mean(temp.ps,2); % rows for Awake/Sleep, columns for channels

end
end

%% PSD plot
% figure('Name',[Mouse,' PSD'])
% for j=1:nState % state
% for jj=1:Electrical.nChannel % channel
%     
% subplot(Electrical.nChannel,2,j+(jj-1)*2)
% plot(temp.fff,Electrical.PSD_cell{j,jj})
% xlim([Settings.HP_ele,50])
%     
% if j==1
%     title(['Awake CH',num2str(jj)])
% else
%     title(['Sleep CH',num2str(jj)]);
% end
%     
% end
% end
% xlabel('Frequency (Hz)'), ylabel('Power \muV^2')
% 
% clearvars temp
%% Convert variables to DataTable 
Mouse=strsplit(Mouse,'_');
Name=Mouse(1);
Genotype=Mouse(2); 
Day=Mouse(3);
Channel={'CH1','CH2','CH3','CH4'};

nPSD_cell=numel(Electrical.PSD_cell);

Name_string=strings(nPSD_cell,1);
Genotype_string=Name_string;
Day_string=Name_string;
Channel_string=Name_string;
State_string=Name_string;
PSD_table_cell=cell(nPSD_cell,1);
Electrical_fs=zeros(nPSD_cell,1);

Name_string(:)=Name;
Genotype_string(:)=Genotype;
Day_string(:)=Day;

count=0;
for d=1:nState % States
    for dd=1:Electrical.nChannel % Channels
    
    count=count+1;    
        
    Channel_string(count)=Channel(dd);
    State_string(count)=Settings.StateString(d);
    PSD_table_cell(count)=Electrical.PSD_cell(d,dd);
    Electrical_fs(count)=Electrical.fs;

    end
end

TableNames={'Name','Genotype','Day','Channel','State','Power','fs'};
DataTable_cell{E_index}=table(Name_string,Genotype_string,Day_string,Channel_string,State_string,...
                PSD_table_cell,Electrical_fs,...
                'VariableNames',TableNames);

% clearvars -except Settings FileName PathName nExperiments experiment_index DataTable_cell DataTable_Select
end

% save datatable and settings
cd ..
DataTable_Automatic=cat(1,DataTable_cell{:});
save(['DataTable_Automatic_Extended.mat'],'DataTable_Automatic')
save('Settings','Settings')